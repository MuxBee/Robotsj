#pragma config(Sensor, S1,     lineLight,      sensorLightActive)
#pragma config(Sensor, S2,     lineColorRight, sensorColorNxtFULL)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     lineColorLeft,  sensorColorNxtFULL)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int maxSize = 20;
const int INBOX = 5;

void remmen(int snelheid)
{
	for(int i = snelheid; i > 0; i --)
	{
		motor[motorB] = i;
		motor[motorC] = i;
		wait1Msec(10);
	}
	motor[motorB] = 0;
	motor[motorC] = 0;
}
void gas(int rechterMotor, int linkerMotor)
{
	motor[motorB] = rechterMotor;
	motor[motorC] = linkerMotor;
}
void kruising(string kant,int snelheid, int richting)
{
	if(richting == 0)
	{
		if(kant == "rechts")
		{
			gas((snelheid/2), (-snelheid/2));
			wait1Msec(250);
		}
		else
		{
			gas((-snelheid/2), (snelheid/2));
			wait1Msec(250);
		}
		gas(snelheid, snelheid);
		wait1Msec(250);
	}
	if(richting == 1)
	{
		if(kant == "rechts")
		{
			gas((snelheid/2), (-snelheid/2));
			wait1Msec(250);
		}
		else
		{
			gas((-snelheid/2), (snelheid/2));
			wait1Msec(250);
		}
		gas(snelheid, snelheid);
		wait1Msec(750);
		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorC] = 0;
		while(nMotorEncoder[motorB] < 505 && nMotorEncoder[motorC] < 505){
			gas(snelheid, -snelheid);
		}
	}
	if(richting == 2)
	{
		if(kant == "rechts")
		{
			gas((snelheid/2), (-snelheid/2));
			wait1Msec(250);
		}
		else
		{
			gas((-snelheid/2), (snelheid/2));
			wait1Msec(250);
		}
		gas(snelheid, snelheid);
		wait1Msec(750);
		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorC] = 0;
		while(nMotorEncoder[motorB] < 505 && nMotorEncoder[motorC] < 505){
			gas(-snelheid, snelheid);
		}
	}
}
char* bluetooth()
{
	TFileIOResult result;
  int size;
  ubyte buffer[maxSize];
  size = cCmdMessageGetSize(INBOX);
  string s = "";

  if (size > maxSize)
    size = maxSize;
  if (size > 0){
  	result = cCmdMessageRead(buffer, size, INBOX);
  	buffer[size] = '\0';
  	stringFromChars(s, (char *) buffer);
  }
  return s;
}

bool rijden2(int snelheid, bool moving, int richting)
{
	string rechts = "rechts";
	string links = "links";
	int remming = 10;

	if(SensorValue[lineColorLeft] == 1)
	{
		if(SensorValue[lineColorRight] != 1)
		{
			for(int i = snelheid; i > -20; i -= remming)
			{
				if(SensorValue[lineLight] >= 50)
				{
					remming = 20;
				}
				gas(snelheid, i);
			}
		}
		else if(SensorValue[lineColorRight] == 0 && richting == 0)
		{
			kruising(links, snelheid, richting);
		}
		else if(SensorValue[lineColorRight] == 1 && richting == 1)
		{
			kruising(links, snelheid, richting);
		}
		else if(SensorValue[lineColorRight] == 1 && richting == 2)
		{
			kruising(links, snelheid, richting);
		}
	}
	else if(SensorValue[lineColorRight] == 1)
	{
		if(SensorValue[lineColorLeft] != 1)
		{
			for(int i = snelheid; i > -20; i -= remming)
			{
				if(SensorValue[lineLight] >= 50)
				{
					remming = 20;
				}
				gas(i, snelheid);
			}
		}
		else if(SensorValue[lineColorRight] == 0 && richting == 0)
		{
			kruising(rechts, snelheid, richting);
		}
		else if(SensorValue[lineColorRight] == 1 && richting == 1)
		{
			kruising(rechts, snelheid, richting);
		}
		else if(SensorValue[lineColorRight] == 1 && richting == 2)
		{
			kruising(rechts, snelheid, richting);
		}
	}
	else
	{
		gas(snelheid, snelheid);
	}
	if(SensorValue[sonar] < 30)
	{
			remmen(snelheid);
			moving = false;
	}
	return moving;
}

task main()
{
	bool moving = true;
	string command;
	int richting = 2;

	while(true)
	{
		int snelheid = 50;
		command = bluetooth();
		if(command == "DOWN")
		{
			remmen(snelheid);
			moving = false;
		}
		if(command == "UP")
		{
			moving = true;
			richting = 0;
		}
		if(command == "LEFT")
		{
			richting = 1;
		}
		if(command == "RIGHT")
		{
			richting = 2;
		}
	  moving = rijden2(snelheid,moving,richting);
	}
}
