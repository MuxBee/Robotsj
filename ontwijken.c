#pragma config(Sensor, S1,     lineLight,      sensorLightActive)
#pragma config(Sensor, S2,     lineColorRight, sensorColorNxtFULL)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     lineColorLeft,  sensorColorNxtFULL)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int maxSize = 20;
const int INBOX = 5;

void remmen(int snelheid)
{
	for(int i = snelheid; i > 0; i --)
	{
		motor[motorB] = i;
		motor[motorC] = i;
		wait1Msec(10);
	}
	motor[motorB] = 0;
	motor[motorC] = 0;
}
void gas(int rechterMotor, int linkerMotor)
{
	motor[motorB] = rechterMotor;
	motor[motorC] = linkerMotor;
}
void scannen(int graden, int rotatie)//Graden is aantal graden te draaien, Rotatie is de snelheid en de richting bepaaling//
{
	nMotorEncoder[motorA] = 0;
	/*
	if(graden < 0)//Checkt of
	{
		while(nMotorEncoder[motorA] < graden)
		{
			motor[motorA] = rotatie;
		}
		motor[motorA] = 0;
	}
	if(graden > 0)
	{*/
	while(abs(nMotorEncoder[motorA]) < graden)// loopt totdat aantal graden is gedraaid.//
	{
		nxtDisplayTextLine(2, "MRotatie: %2.2f", abs(nMotorEncoder[motorA]));
		motor[motorA] = rotatie;
	}
	motor[motorA] = 0;//Als script gedraaid heeft dan wordt de motor stil gezet.//
	//}

}
char* bluetooth()
{
	TFileIOResult result;
  int size;
  ubyte buffer[maxSize];
  size = cCmdMessageGetSize(INBOX);
  string s = "";

  if (size > maxSize)
    size = maxSize;
  if (size > 0){
  	result = cCmdMessageRead(buffer, size, INBOX);
  	buffer[size] = '\0';
  	stringFromChars(s, (char *) buffer);
  }
  return s;
}


int ontwijken(int rotatie)
{																							//Displayed text op nxt schrem//
	nxtDisplayTextLine(0, "====ONTWIJKEN====");	//Naam functie//
	nxtDisplayTextLine(2, "MRotatie: 0.00");		//Rotatie Motor//
	nxtDisplayTextLine(3, "Locatie:  0.00");		//Welke stap het process is(0-4)//
	nxtDisplayTextLine(4, "Afstand:  0.00");		//Meeting welke afstand af gelegd is in een deel can de functie//
	nxtDisplayTextLine(7, "       -Muscio97");	//Auteur//

	int static locatie = 0;//locatie wordt eenmaalig in de functie op waarde 0 gezet//
	if(rotatie > 50)//Locatie is de huidige stap van het process//
	{
		rotatie = 50;//rotatie wordt wegens stabiliteits redenen naar 50 gezet, als er een hoger getal ingevoerd is//
	}
	if(SensorValue[sonar] < 30)//Test of er een object voor NXT staat//
	{
		while(locatie <= 4)//Onderstaande script bijlft draaien totdat alle stappen voldaan zijn//
		{
			if(SensorValue[sonar] < 30)
			{
				//remmen(snelheid);
				scannen(90, (rotatie/4));//Sonar wordt naar links gedraaid//
				if(SensorValue[sonar] < 30)//Als daar een object is//
				{
					scannen(180, -(rotatie/4));//Dan wordt de sonar naar rechts gedraaid//
					if(SensorValue[sonar] < 30)//Als Links EN Rechts objecten zijn//
					{
						gas(-rotatie,-rotatie);//Dan zal de NXT achteruit gaan//
						wait10Msec(5300/rotatie);
						remmen(rotatie);
						scannen(90, (rotatie/4));//Sonar draaid terug naar het "nul punt", in het verlengde van de NXT "recht"//
						return 1;//functie wordt "gesloten", zodat de omgeving opnieuw kan worden gescand//

							//subfunctie opnieuw checken//

					}
					else//Als Rechts geen object is//
					{
						gas(rotatie, -rotatie);//Dan zal de NXT naar rechts draaien//
						wait10Msec(5300/rotatie);	//Een hogeren snelheid vraagt om minder tijd om de zelfde afstand afteleggen//
						remmen(rotatie);					//Dus de tijd wordt gedeeld door huidge snelheid//
						scannen(90, (rotatie/4));	//Sonar draaid terug naar het "nul punt", in het verlengde van de NXT "recht"//
						if(!SensorValue[sonar] < 30)
						{
							gas(rotatie, rotatie);//NXT rijd vooruit//
							wait10Msec(25);
							locatie++;//Stap 1 voldaan//
							scannen(90, (rotatie/4));	//Sonar wordt naar links gedraaid//
							while(SensorValue[sonar] < 30)
							{
								gas(rotatie, rotatie);//Zolang de NXT een object detecteerd, zal de unit door blijven rijden//
							}
							gas(-rotatie,rotatie);//Als de NXT geen object (meer) ziet, dan zal die Links draaien//
							wait10Msec(5300/rotatie);
							scannen(90, (rotatie/4));//Sonar draaid terug naar het "nul punt", in het verlengde van de NXT "recht"//
							if(!SensorValue[sonar] < 30)
							{
								gas(rotatie, rotatie);
								wait10Msec(25);
							}

							//Weer bocht maken// //rijden totdat lijn gevonden is// //Bocht maken//
						}
					}
				}
				else
				{//Als links geen object is//
					gas(-rotatie, rotatie);//Dan zal de NXT naar links draaien//
					wait10Msec(5300/rotatie);
					remmen(rotatie);
					scannen(90, -(rotatie/4));//Sonar draaid terug naar het "nul punt", in het verlengde van de NXT "recht"//
					if(!SensorValue[sonar] < 30)
						{
							gas(rotatie, rotatie);
							wait10Msec(25);
							locatie++;//stap 1 voldaan//
							scannen(90, -(rotatie/4));//Sonar wordt naar rechts gedraaid//
							while(SensorValue[sonar] < 30)
							{
								gas(rotatie, rotatie);//Zolang de NXT een object detecteerd, zal de unit door blijven rijden//
							}
							scannen(90, (rotatie/4));//Sonar draaid terug naar het "nul punt", in het verlengde van de NXT "recht"//
							gas(rotatie,-rotatie);//Als de NXT geen object (meer) ziet, dan zal die rechts draaien//
							wait10Msec(5300/rotatie);
							//remmen(rotatie);
						}
					}
					//remmen(rotatie);
			}
		}
	}
	return 0;
}

bool rijden(int snelheid, bool moving, bool kruispunt, int richting)
{
	int remming = 10;

	string command;
//	bool kruispunt = 0;
	ontwijken(100);
	if(moving && !kruispunt)
	{
		if(SensorValue[lineColorLeft] != 1 && SensorValue[lineColorRight] != 1) //Rechtdoor Rijden
		{
			if(SensorValue[lineLight] < 50)
			{
				gas(snelheid,snelheid);
			}
		}
		else if(SensorValue[lineColorLeft] != 1 && SensorValue[lineColorRight] == 1) //Bocht naar rechts.
		{
			snelheid = 20;
			for(int i = snelheid; i > 0; i -= remming)
			{
				if(SensorValue[lineLight] >= 50)
				{
					remming = 15;
				}
				gas(i, snelheid);
			}
		}
		else if(SensorValue[lineColorLeft] == 1 && SensorValue[lineColorRight] != 1) // Bocht naar links.
		{
			snelheid = 20;
			for(int i = snelheid; i > 0; i -= remming)
			{
				if(SensorValue[lineLight] >= 50)
				{
					remming = 20;
				}
				gas(snelheid, i);
			}
		}

	}
	if(moving && kruispunt)
	{

		if(richting == 1)
		{
			snelheid = 40;
			if(SensorValue[lineColorLeft] != 1 && SensorValue[lineColorRight] != 1) //Rechtdoor Rijden
			{
				if(SensorValue[lineLight] < 50)
					{
						gas(snelheid,snelheid);
					}
			}

			if(SensorValue[lineColorLeft] == 1 && SensorValue[lineColorRight] == 1) // Linksaf met kruispunt
			{
			while(snelheid != remming){
				for(int i = snelheid; i > 0; i -= remming)
				{
					if(SensorValue[lineLight] >= 50)
					{
						remming = 5;
					}
					gas(snelheid, i);

				}
				if(SensorValue[lineColorLeft] != 1 && SensorValue[lineColorRight] != 1 && SensorValue[lineLight] < 50)//van lijn
					{
						snelheid = remming;
						richting = 0;
						kruispunt = false;
					}
				}
			}
	//			kruispunt = false;
		//		richting = 0;

				moving = true;
		}

		if(richting == 2)
		{
			snelheid = 30;
			if(SensorValue[lineColorLeft] != 1 && SensorValue[lineColorRight] != 1) //Rechtdoor Rijden
			{
				if(SensorValue[lineLight] < 50)
					{
						gas(snelheid,snelheid);
					}
			}

			if(SensorValue[lineColorLeft] == 1 && SensorValue[lineColorRight] == 1)
			{

				while(SensorValue[lineColorLeft] == 1 && SensorValue[lineColorRight] == 1)
				{
						gas(0,100);
						wait1Msec(13);
				}

				kruispunt = false;
				richting = 0;
				moving = true;
				moving = rijden(snelheid,moving,kruispunt,richting);
			}
		}

	}

	return moving;
}

task main()
{
	bool moving;
	int richting = 0;
	bool kruispunt = false;
	bool startE = false;
	string command;


	while(true)
	{
		int x;

		int snelheid = x;
		command = "UP";//bluetooth();

		if(command == "DOWN")
		{
			remmen(snelheid);
			moving = false;
		}
		if(command == "UP" && !startE)
		{
			moving = true;
			x = 100;
		}
		if(command == "FIRE")
		{
			//schieten(2);
		}

		if(command == "LEFT")
		{
			kruispunt = true;
			richting = 1;
		}
		if(command == "C")
		{
			kruispunt = false;
			richting = 0;
			snelheid = -25;
		}
	  moving = rijden(snelheid,moving,kruispunt,richting);
	}



}
